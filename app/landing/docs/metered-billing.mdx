---
title: "Metered billing"
description: "Charge customers based on usage with credits and metered products"
---

Metered billing charges customers based on **actual usage** — e.g. API calls, storage (MB), AI tokens, or any measurable metric. In Stellar Tools this is done with **credits** and **metered products**.

## How it works

1. **Create a metered product** — Define a product with `type: "metered"`, a **unit** (e.g. `"tokens"`, `"MB"`), and how usage converts to credits.
2. **Customers get a credit balance** — When a customer purchases or is granted access to the metered product, they get a credit balance (e.g. 1,000 credits).
3. **Report usage** — Your app (or an adapter like LangChain, AI SDK, Uploadthing) calls the **Credits API** to **deduct** credits when the customer uses the service. You send the raw amount (e.g. 500 tokens); the API converts to credits using the product’s conversion rules.
4. **Optional: refund or grant** — Use the same API to **refund** credits (undo a charge) or **grant** more credits.

Credits are scoped per **customer** and per **product**. Each metered product has its own balance and transaction history.

## Metered product fields

When creating a product with `type: "metered"`, set:

| Field | Description |
|-------|-------------|
| `unit` | Human-readable unit name (e.g. `"tokens"`, `"MB"`, `"API calls"`). Shown in dashboard and statements. |
| `unitDivisor` | Divide raw usage by this before converting to credits. Example: `1` for “1 unit = 1 unit”, or `1_000_000` so 1,000,000 bytes = 1 “unit” for credit math. |
| `unitsPerCredit` | How many (post-divisor) units equal **1 credit**. Example: `10` means 10 units = 1 credit. |
| `creditsGranted` | Initial credits the customer gets when they purchase or are granted this product. |
| `creditExpiryDays` | Optional. Credits expire after this many days (if your product supports expiry). |

**Credit formula:** `credits = ceil((rawAmount / unitDivisor) / unitsPerCredit)`  
Example: raw 50,000 tokens, `unitDivisor: 1`, `unitsPerCredit: 10` → 5,000 credits.

## Credits API

Use these endpoints to manage balances and usage:

- **[Get credit balance](/api-reference/credits#get-credit-balance)** — `GET /api/customers/:customerId/credits/:productId` — Current balance, consumed, and granted for that customer/product.
- **[List credit transactions](/api-reference/credits#list-credit-transactions)** — `GET /api/customers/:customerId/credits/transactions` — History of deduct, refund, and grant (with optional `productId`, `limit`, `offset`).
- **[Post credit transaction](/api-reference/credits#post-credit-transaction)** — `POST /api/customers/:customerId/credits/:productId/transaction` — Deduct, refund, or grant. Send `amount` in **raw units** (e.g. tokens); the API converts to credits. Optional `dryRun: true` to check sufficiency without applying.

<Card
  title="Credits API reference"
  icon="coins"
  href="/api-reference/credits"
  horizontal
>
  Full request/response details for balance and transactions.
</Card>

## Adapters that use metered billing

- **[LangChain](/adapters/langchain)** — Meter LLM usage (tokens) per request.
- **[AI SDK](/adapters/aisdk)** — Meter Vercel AI SDK `streamText` / `streamObject` by token usage.
- **[Uploadthing](/adapters/uploadthing)** — Meter by total upload size (bytes).
- **[Better Auth](/adapters/betterauth)** — Exposes `/stellar/credits/consume` and `/stellar/credits/transactions` for your app.

You can also call the Credits API directly from your backend to implement custom metered features (e.g. API call counting, storage, compute time).

## Flow example

1. Create metered product: `"AI tokens"`, `unit: "tokens"`, `unitDivisor: 1`, `unitsPerCredit: 10`, `creditsGranted: 1000`.
2. Customer buys or is granted access → they get 1,000 credits.
3. Customer makes a request that uses 250 tokens → your server calls `POST .../transaction` with `{ "amount": 250, "type": "deduct" }` → 25 credits deducted (250/10).
4. Balance is now 975 credits. You can show this in your UI by calling `GET .../credits/:productId`.
